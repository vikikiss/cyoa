\documentclass[12pt,a4paper,oneside]{report}

\usepackage{txfonts}
% \usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
\usepackage{ucs}
\usepackage{fontspec}
\usepackage[magyar]{babel}
\usepackage{amssymb}
\usepackage{paralist}
\usepackage{minted}
\usemintedstyle{vs}
\usepackage{graphicx}
\usepackage[colorlinks=true,urlcolor=blue,citecolor=black,linkcolor=black]{hyperref}
% \usepackage[usenames,dvipsnames]{color}

\definecolor{Tag}{RGB}{38,107,189}
\definecolor{Attr}{RGB}{238,0,0}
\definecolor{Value}{RGB}{59,125,37}
\definecolor{CodeBg}{RGB}{232,232,232}
\definecolor{Keyword}{RGB}{180,82,205}
\definecolor{Cons}{RGB}{0,139,0}

\newcommand{\xtag}[1]{{\color{Tag}#1}}
\newcommand{\xattr}[2]{{\color{Attr}#1}={\color{Value}''#2''}}

\newcommand{\stat}{\textsc}
\newcommand{\attr}{\emph}
\newcommand{\proglang}{\texttt}

\newcommand{\kif}{\emph{kif}}
\newcommand{\felt}{\emph{felt}}
\newcommand{\ut}{\emph{ut}}

\begin{document}
\input{title}
\tableofcontents

\newcommand{\chap}[1]{
  \addcontentsline{toc}{chapter}{#1}
  \addtocounter{chapter}{1}
  \setcounter{section}{0}
  \phantomsection
  \chapter*{#1}
}

\addcontentsline{toc}{chapter}{Bevezető}
\chapter*{Bevezetés}

  A nagyprogramom alapjául a '80-'90-es évek \emph{Kaland Játék Kockázat}
  könyvei szolgáltak. Ezekben a könyvekben nem hagyományos történetek
  szerepelnek, tehát nem az előre megírt kalandot, történetet olvassa el
  az olvasó, helyette sok apró fejezetre van bontva a cselekmény, melyek
  végén választási lehetőség áll. Így az olvasóra van bízva, hogy hogyan
  folytatja tovább a történetet. Vagyis az olvasó lehet maga a kalandor,
  aki kedve szerint formálhatja a történéseket attól függően, hogy
  mennyire bátor, kíváncsi, leleményes és kalandvágyó. Ezek a kalandok
  nagyrészt nem valós történeteket foglalnak magukba, hanem a fantázia
  világában játszódnak, meseszerű fordulatokkal, mesebeli lényekkel. Az
  olvasónak, vagyis a történet hősének így óriásokkal, szörnyekkel kell
  megvívni, hogy elérje a kitűzött célt, melyet a kaland elején kap.
  
  Ám sajnos a kalandot el is lehet bukni. Vannak olyan helyek, ahol
  csapdába eshetünk, vagy egy gonosz lény felül kerekedik rajtunk, és
  nem tudjuk legyőzni. Ahhoz, hogy sikeresen végigjátszuk szükségünk
  van \stat{ügyességre}, \stat{szerencsére} és \stat{életerőre}. Ez a
  három dolog, ami jellemez egy hőst.

  Mivel a játékos mondja meg, hogy mi legyen a következő lépés, ő
  befolyásolja a további történést, ezért jó ötletnek találtam ezt
  megvalósítani egy programozási nyelven. Minden oldal elején a történet
  folytatódik és az oldal végeztével a játékos megmondhatja, hogy
  melyik kínálkozó utat választja. Így folyamatos interakcióra van
  szükség a játékos részéről. Miután eldöntötte, hogy merre folytatja
  kalandját, átmegy arra az oldalra, ahol további kalandok, veszélyek
  leselkednek rá.
  
  Az eredeti játék az volt, hogy a könyvet olvasva a játékos
  kigyűtötte magának az információkat, amelyet kalandja során
  tapasztalt, így szükség volt egy papírlapra, melyen vezette, hogy
  mennyi aktuálisan az \stat{életereje}, \stat{szerencséje},
  \stat{ügyessége}. Illetve, ha talált egy tárgyat, amit fel lehet
  venni, azt is felírta, hogy használni tudja később, amikor szükség
  van rá. Emellett két dobókocka is kellett, mert a szörnyek elleni
  harcnál a véletlen dönt, hogy ki sebez kit. Azonban a nagyprogramom
  végigjátszásánál nincs szükség ezekre a kellékekre, mert a program
  állapota tárolja, hogy milyen eszközöket vettünk fel, mennyi az
  \stat{életerő}, \stat{szerencse} és \stat{ügyességi pontjaink},
  mennyit dobtunk a dobokockával, stb.
  
\chap{Felhasználói dokumentáció}

    \section{Játékszabályok}
  
      \subsection{Ügyesség, életerő, szerencse pontok}
        Mielőtt elkezdünk egy játékot meg kell határoznunk a fent
        említett \stat{életerő}, \stat{szerencse} és \stat{ügyességi
        pontjainkat}. Ahhoz, hogy megkapjuk az \stat{ügyességi
        pontainkat} dobjunk a dobókockával, majd a kapott számhoz
        adjunk hozzá 6-ot. Ugyanígy járjunk el a \stat{szerencse
        pontjaink} meghatározásához is. Hogy \stat{életerő
        pontjainkat} megtudjuk dobjunk két dobókockával és adjunk
        hozzá 12-t. Ezek az értékek a kalandok során folyamatosan
        változni fognak, de nem csökkenhetnek 0 alá, és pont
        visszaszerzés során nem mehetnek a kezdeti érték fölé. Az
        \stat{ügyességi pontok} mutatják, hogy mennyire tudunk jól
        harcolni, mennyire vagyunk tapasztaltak. Az \stat{életerő
        pont} azt jelzi, mennyire vagyunk egészségesek, erősek. A
        \stat{szerencse}, pedig természetesen a szerencsénket jelzi.
    
      \subsection{Csata}
        Sűrűn találkozhatunk kalandunk során olyan oldallal, ahol meg
        kell küzdenünk egy különleges teremtménnyel, mesebeli
        szörnnyel. A szörny is rendelkezik hasonló tulajdonságokkal,
        mint mi, vagyis neki is van \stat{ügyességi} és \stat{életerő
        pontja}, viszont nincs \stat{szerencse pontja}.  Amikor
        elérkezünk a csatához, akkor körökre bontva támadunk. Vagy a
        lény támad minket, vagy mi a lényt. Ennek eldöntésére
        használjuk a dobókockát, hogy véletlenszerű legyen. Ezeket a
        köröket addig csináljuk, amíg valakinek az életereje le nem
        csökken 0-ra. Ha a szörny életereje lemegy 0-ra, akkor mi
        győztünk, ellenkező esetben vesztettünk és újból kell
        kezdenünk az egész kalandunkat, nem csak a harcot. Egy kör az
        alábbi módon néz ki:
        \begin{enumerate}
          \item Dobjunk két kockával a szörny nevében, és két kockadobás összegét adjuk
            hozzá a szörny ügyességi pontjaihoz. Ez lesz az ő \textsc{támadóereje} ebben a körben.
          \item Dobjunk két kockával a saját nevünkben és hasonlóan, mint az előbb,
            ezt az összeget adjuk hozzá a mi ügyességi pontjainkhoz. Ez a saját
            \textsc{támadóerőnk}.
          \item Ekkor össze kell hasonlítani a kapott két számot.
            \begin{itemize}
              \item Abban az esetben ha megegyeznek, akkor kivédtük egymás
                támadását. Nem sérült senki, nem kerekedett felül senki. Kezdhetjük
                elölről a kört. Minden marad ugyanúgy.
              \item Ha a mi \textsc{támadóerőnk} a nagyobb, akkor mi sebeztük a szörnyet. Így a
                szörny \stat{életerejéből} levonunk 2-t.
              \item Ha az ő \textsc{támadóereje} a nagyobb, akkor sebzést kaptunk, így a mi
                \stat{életerőnk} csökken 2-vel.
              \item Viszont ezek után még lehetőségünk van javítani az
                eredményen. Próbára tehetjük a szerencsénket, ami azt jelenti, hogy
                ismét dobnunk kell mindkét dobókockával. Ha a kapott számok összege
                kisebb vagy egyenlő, mint a jelenlegi \stat{szerencse pontjaink} száma,
                akkor vagyunk szerencsések, ellenkező esetben
                balszerencsések.
                \begin{compactitem}[--]
                  \item Ha mi sebeztünk és szerencsénk volt, az azt jelenti, hogy további sebzést
                    tudtunk bevinni a szörnynek, így még 2 pontot levonhatunk tőle.
                  \item Ha mi sebződtünk és szerencsétlenek voltunk, akkor a szörnynek sikerült
                    még egy csapást bevinni, ezért mi még 2 pontot vesztünk.
                  \item Ha mi sebeztünk, de szerencsétlenül jártunk, akkor egy pontot
                    visszakap az ellenfél.
                  \item Ha sebzést kaptunk és szerencsétlenek voltunk, akkor még egy
                    pontot elveszítünk.
                \end{compactitem} 
            \end{itemize}
            Minden esetben, amikor igénybe vesszük a
            szerencsénket, akkor a szerencsepontjaink száma eggyel csökken.
          \item A kör végén ellenőriznünk kell, hogy nem csökkent-e le a mi vagy az
            ellenfelünk \stat{életerő pontja} 0-ra. Abban az esetben ha igen, akkor vagy
            legyőztük a szörnyet, és folytathatjuk tovább kalandunkat, vagy ha
            az ellenfél győzőtt le minket, akkor elölről kell kezdeni az egész
            kalandot az első oldaltól.
        \end{enumerate} 
      \subsection{Szerencse}
        Nemcsak csatában szorítkozhatunk a szerencsénkre, hanem
        találkozhatunk azzal az utasítással, hogy \emph{Tedd próbára a
          szerencsédet!}. Alapvető különbség, hogy míg a csatában mi
        dönthetjük, hogy szeretnénk-e kockáztatni, addig itt
        kötelező. Ekkor nem mi döntünk sorsunk alakulásáról, hanem a
        szerencse befolyásolja kalandunk további menetét. Hasonlóan,
        mint a csatában dobnunk kell a két kockával egyszerre. Ha az
        összegük kevesebb vagy egyenlő, mint a \stat{szerencse
          pontjaink} száma, akkor szerencsések vagyunk. Ha azonban
        nagyobb, akkor szerencsétlenek vagyunk. Ennek fényében kell
        tovább folytatni a kalandunkat. Minden szerencsepróba után a
        szerencse pontjaink száma eggyel csökken.
    
      \section{Játék menete}
        A kaland az 1. oldalon kezdődik és minden oldal végén választani kell,
        hogy merre szeretnénk tovább haladni. Van, hogy csak két út áll
        előttünk, de van, hogy sok lehetőség közül választhatunk. Cél, hogy
        eljussunk a 400. oldalra (ahol a győzelem vár ránk), melynek eléréséhez
        különböző megmérettetések, harcok, próbák, észjátékok várnak ránk.
        Először kockadobásokkal meghatározzuk a tulajdonságainkat, majd
        elolvashatjuk a háttértörténetet, amelyből kiderül, hogy a hősnek,
        akinek kalandjait mi választjuk meg, mi a célja, honnan indul és
        hová akar érkezni.
    \section{Program indítása, használata}
      TODO
      
\chap{Fejlesztői dokumentáció} A nagyprogramot \proglang{Haskell}
nyelven implementáltam. Alapvetően két részből áll maga a program, egy
motorból és a megjelenítésből. A program bemenete egy \proglang{xml}
fájl. A motor beolvassa ezt a fájlt, átfordítja egy saját nyelvre, ott
elvégzi a műveleteket, állapotváltozásokat, majd előállít egy
kimenetet. Ezt a kimenetet bárhogy fel lehet dolgozni, én két féle
feldolgozást implementáltam. Az egyik egy graf{}ikus felhasználói
felület, a másik egy webes megvalósítás. Ebből látszik, hogy teljesen
elkülönül egymástól a motor és a megjelenítés.

  \section{Dokumentáció a történetíráshoz}
    Mivel a program egy \proglang{xml} fájlt olvas be, ezért ott kell
    leírni, hogy a könyv különböző sorai milyen műveleteket
    takarnak. Maga az olvasó is találhat ki történeteket. Ehhez az
    \proglang{xml} szerkezetének ismerete szükséges.

    \subsection{Oldal alapvető leírása}
      \begin{itemize}
        \item <\xtag{book}> <\xtag{/book}> : Gyökér jelölő.

        \item <\xtag{page} \xattr{id}{400} \xattr{win}{1}>
          <\xtag{/page}>: A könyv oldalakból tevődik
          össze. Minden új oldal egy ilyen jelölőbe
          kerül. Attribútumai: \attr{id}, \attr{death}, \attr{win}.
          Az \attr{id} attribútum kötelező, ez mondja meg, hogy
          hányadik oldalon vagyunk. A másik két attribútum csak
          különleges helyzetekben szerepel. A \attr{death} attribútum
          azt az információt hordozza magában, hogy az oldal, amire
          érkeztünk olyan oldal, ahonnan nincs tovább vagyis a hős
          kalandja itt véget ér, elbukta küldetését. Hasonlóan a
          \attr{win} attribútum jelentése, hogy a hős elérkezett
          céljához, tehát győzött. A nyitó csukó jelölők közé további
          jelölők jönnek.
          
        \item <\xtag{p}> <\xtag{/p}> : bekezdést jelöl, tehát ennek a
          segítségével tudjuk a szöveget tagolni, hogy átláthatóbb,
          olvashatóbb legyen. Így a nyitó és záró jelölő közé főként
          szöveg kerül, de lehetnek további jelölők is.
      \end{itemize}
      
    \subsection{Események}
      \begin{itemize}
        \item <\xtag{dice} \attr{name}{d}/>
          : Kockadobás. A \attr{name} attribútum a kocka nevét jelöli,
          mert esetenként több kockadobásra is szükségünk van. Tehát
          meg kell tudnunk különböztetni őket.
    
        \item <\xtag{take} \xattr{item}{\emph{tárgy}}/>          
          : Eszköz felvétele. Kalandunk során számon kell tartanunk,
          hogy milyen eszközökre tettünk szert. Ezekre leginkább a
          későbbiekben lesz szükségünk. Elérkezhetünk egy olyan
          megmérettetéshez, melynek sikeressége az adott tárgy
          birtoklásán múlhat.
    
        \item <\xtag{drop} \xattr{item}{tárgy}/>          
          : Tárgy eldobása, felhasználása. Ha felhasználunk egy
          korábban megszerzett tárgyat, de az már a későbbiekben nem
          marad nálunk, akkor használjuk ezt a jelölőt.
    
        \item <\xtag{set-flag} \xattr{flag}{flag}/>
          : Szükségünk lehet arra is, hogy megjegyezzünk olyan
          dolgokat, hogy már megtörtént velünk valami, pl. jártunk már
          egy bizonyos helyen. A későbbiekben lehet erre utaló kérdés,
          mely befolyásolhatja utunkat.
          
        \item <\xtag{heal} \xattr{stat}{\emph{stat}}>\kif<\xtag{/heal}>
          : A \emph{stat} attribútum által meghatározott
          jellemzőnk(\stat{életerő}, \stat{ügyesség} vagy \stat{szerencse})
          növelése. Annyival nő az értéke, amennyi a nyitó és záró
          jelölő közötti kifejezés értéke.
          
        \item <\xtag{damage} \xattr{stat}{\emph{stat}}>\kif<\xtag{/heal}>
          : A \emph{stat} attribútum által meghatározott
          jellemzőnk(\stat{életerő}, \stat{ügyesség}, \stat{szerencse})
          csökkentése. Annyival lesz kevesebb az értéke, amennyi a nyitó
          es záró jelölő közötti kifejezés értéke.
    
        \item <\xtag{inc} \xattr{counter}{\emph{számláló}}/> 
          : Lehet az a feladatunk a kaland során, hogy egy adott
          tárgyból össze kell gyűjtenünk többet. Ennek a segítségével
          tudjuk az adott eszköz számát nyilvántartanunk, tehát ha
          találunk egy újabbat, akkor csak annyit jegyzünk meg, hogy
          találtunk még egyet.
          
        \item <\xtag{dec} \xattr{counter}{\emph{számláló}}/>           
          : Hasonlóan az előző jelölőhöz, ez arra szolgál, amikor a
          gyűjtött dologból elveszítünk vagy felhasználunk egyet.

        \item <\xtag{clear} \xattr{counter}{\emph{számláló}}/>            
          : A gyűjtött tárgyakat elveszítjük, azaz a száma 0 lesz.
      \end{itemize}

    \subsection{Vezélési szerkezetek}
      \subsubsection{Feltételek}
        \begin{itemize}
          \item <\xtag{lt}>\kif$_1$ \kif$_2$<\xtag{/lt}> : $<$. (Kisebb.) Binér
            reláció, tehát két argumentuma van. Igaz értékkel tér vissza,
            ha az első argumentum kisebb, mint a második. Az argumentumai
            lehetnek változóhivatkozások, számliterálok.
            
          \item <\xtag{le}>\kif$_1$ \kif$_2$<\xtag{/le}> : $\le$. (Kisebb vagy
            egyenlő.) Binér reláció. Igaz az értéke, ha az első argumentum
            kisebb vagy egyenlő, mint a második.
            
          \item <\xtag{gt}>\kif$_1$ \kif$_2$<\xtag{/gt}> : $>$. (Nagyobb.) Binér
            reláció. Igaz, ha az első argumentum nagyobb, mint a második.
            
          \item <\xtag{ge}>\kif$_1$ \kif$_2$<\xtag{/gt}> : $\ge$. (Nagyobb vagy
            egyenlő.) Binér reláció. Igaz, ha az első argumentuma nagyobb
            vagy egyenlő, mint a második.
            
          \item <\xtag{eq}>\kif$_1$ \kif$_2$<\xtag{/eq}> : $=$. (Egyenlő.)
            Binér reláció. Igaz, ha a két argumentuma egyenlő.
            
          \item <\xtag{and}>\felt$_1$ \felt$_2$<\xtag{/and}> : És. Argumentumai
            logikai értékek. Igaz értékkel tér vissza, ha minden
            argumentumának értéke igaz, különben hamis értekkel.
            
          \item <\xtag{or}>\felt$_1$ \felt$_2$ <\xtag{/or}> : Vagy. Argumentumai
            logikai értékek. Igaz értékkel tér vissza, ha van olyan
            argumentuma, amelynek értéke igaz, különben hamissal.
            
          \item <\xtag{not}>\felt<\xtag{/not}> : Negáció. Egy
            argumentuma van, mely egy logikai érték. Igazhoz hamisat,
            hamishoz igazat rendel.
          \item <\xtag{carry} \xattr{item}{\emph{tárgy}}/>
            : Rendelkezünk-e az
            adott tárggyal. Amennyiben igen, akkor az értéke igaz,
            ellenkező esetben hamis.
            
          \item <\xtag{score} \xattr{stat}{\emph{stat}}/>
            : A \attr{stat}
            attribútumban meghatározott jellemzőnk lekérdezése.
        \end{itemize}

      \subsubsection{Kifejezések}
        \begin{itemize}
          \item <\xtag{cond}>\felt \kif$_1$ \kif$_2$<\xtag{/cond}> : Feltétel. Három
            argumentuma van. Amennyiben az első argumentum értéke igaz,
            akkor a második argumentumra kerül a vezérlés, különben a
            harmadikra.
          \item <\xtag{var} \xattr{ref}{d}/>
            : Változóhivatkozás. A \emph{d} változó értékét adja
            vissza. A <\xtag{dice}/> jelölőnél megadtuk a kockadobás nevét és
            értékét, mely értékre később szükégünk van, hogy például
            összehasoníthassuk más értékkel. Ennek a jelölőnek a
            segítségével tehetjük ezt meg.
            
          \item <\xtag{intlit} \xattr{value}{$n$}/>
            : Számliterál. A
            \attr{value} attribútumban kapott szám az értéke.
    
          \item <\xtag{plus}>\kif$_1$ \kif$_2$<\xtag{/plus}> : Két argumentuma
            van, visszaadja ezeknek az attribútumoknak az összegét.

          \item <\xtag{counter}
            {\color{Attr}name}={\color{Value}''item''}/> : A \attr{name}
            attribútumban meghatározott tárgy számát adja meg, azaz hogy
            mennyit sikerült összegyűjtenünk belőle.
            
        \end{itemize}

      \subsubsection{Utasítások}
        \begin{itemize}
          \item <\xtag{if}>\felt \ut$_1$ \ut$_2$<\xtag{/if}> : Elágazás. Van egy
            feltétele, melynek teljesülése esetén az igaz ágra kerül a
            vezérlés, különben a hamis ágra. Lehetséges az is, hogy nincs
            hamis ág. Ebben az esetben, ha a feltétel nem teljesül, akkor
            a következő jelölővel folytatódik a történet.  pl:

          \item <\xtag{text}>\emph{szöveg}<\xtag{/text}>: Szöveg
            kiiratása. Nem új bekezdésben folytatódik a szöveg, hanem az
            adott sorban.
      \end{itemize}

            
    \subsection{Interakció}
      \begin{itemize}
        \item <\xtag{goto} \xattr{ref}{\emph{oldalszám}}/>          
          : Az adott oldal befejeztével hová tudunk továbbmenni. A
          \attr{ref} attribútum mondja meg, hogy hol folytathatjuk
          kalandunkat. Ennek a jelölőnek a hatása, hogy az oldalra
          kikerül a \emph{,,lapozz a 2. oldalra''} szöveg.
    
        \item <\xtag{Goto} \xattr{ref}{\emph{oldalszám}}/>          
          : Hasonló az előzőhöz. A különbség köztük, hogy míg az
          előző jelölőt egy mondat közepén vagy végén használjuk,
          addig ez egy új mondatot állít elő a
          kimenetben. \emph{,,Lapozz a 2. oldalra.''}
    
        \item <\xtag{goto-lucky} \xattr{refYes}{135} \xattr{refNo}{273}/>
          : Tedd próbára a
          szerencsédet!. Attribútumai: \attr{refYes}, \attr{refNo}. Két
          kockadobásra van szükségünk. Amennyiben a kockadobások
          szerencsét hoztak nekünk, akkor a \attr{refYes} attribútum
          által meghatározott oldalra megyünk, ellenkező esetben a
          \attr{refNo} attribútum mondja meg, hogy kalandunk merre
          folytatódjon.

        \item <\xtag{f{}ight}> <\xtag{/f{}ight}> : Harc egy
          mesebeli lénnyel. A nyitó és csukó jelölők között egy vagy
          több <\xtag{enemy}> szerepel, attól függ, hogy hány ellenféllel
          kell megküzdeni.
        \item <\xtag{enemy} \xattr{agility}{10} \xattr{health}{8}>Ogre<\xtag{/enemy}>
          : Az ellenfél, akivel harcolnunk kell. Az attribútumai
          megadják a lény \stat{ügyességét} és \stat{ételerejét}. A
          jelölők közti szöveg, pedig a nevét.
      \end{itemize}
      
    \subsection{Példák}
    \begin{itemize}
      \item Egyszerű oldal
        \begin{minted}{xml}
<page id="7">
  <p>
    Hamarosan egy újabb ajtóhoz érsz az alagútban.
    A kilincs enged, de az ajtót keresztben bedeszkázták.
    Ha le akarod feszíteni a deszkákat a kardoddal - <goto ref="336"/>.
    Ha inkább továbbmész az alagútban - <goto ref="45"/>.
  </p>
</page>
      \end{minted}
      Ez a példa azt mutatja be, hogy hogyan épül fel egy egyszerű
      oldal. Kívül található a <\xtag{page}> jelölő, amely egy
      oldalt hivatott leírni. \attr{Id} attribútuma azt jelenti, hogy a
      7. oldalon vagyunk. Ezen belül <\xtag{p}> jelölőben
      található a történet szövege. Végül az oldal befejezését jelző
      <\xtag{goto}>, amelyben a lehetséges folyatásokat írjuk
      le.
      \item Kockadobás
      
        \begin{minted}{xml}
<p>
  Dobj két kockával! <dice name="d1"/> <dice name="d2"/>
  <if>
    <le>
      <plus>
        <var ref="d1"/>
        <var ref="d2"/>
      </plus>
      <score stat="agility"/>
    </le>
    <text>
      Ha a kapott összeg ugyanannyi vagy kevesebb,
      mint ÜGYESSÉGI pontjaid száma - <goto ref="66"/>.
    </text>
    <text>
      Ha a kapott összeg nagyobb, mint ÜGYESSÉGI
      pontjaid száma - <goto ref="334"/>.
    </text>
  </if>
</p>
        \end{minted}
        A kaland során lehet, hogy a véletlenre szeretnénk bízni, hogy
        hősünkkel mi történjen. Ennek megoldására szolgál a
        kockadobás. Ebben az összetett példában azt írtam le, hogy
        dobunk két kockával, és amennyiben az összegük kisebb vagy
        egyenlő, mint a kalandor ügyességi pontja, akkor a 66-os oldalon
        folytathatja a történetét, különben a 334-en.\\
        A <\xtag{dice}> jelölő a
        kockadobást jelenti, ahol a két kockánk a \emph{d1} és \emph{d2}. A névre majd
        a hivatkozásnál lesz szükségünk. Majd egy <\xtag{if}> elágazás
        következik, ahol az <\xtag{le}> jelölővel megnézzük, hogy az első
        argumentum kisebb vagy egyenlő-e, mint a második. Az első
        argumentum összetett, egy <\xtag{plus}> található benne, melynek
        jelentése, hogy a két kapott argumetumot összeadjuk. A két
        argumentum 1-1 változóhivatkozás, azaz az előbb kapott két
        kockadobás eredménye, melyet a <\xtag{var}> jelölővel kérdezünk
        le. Utána következik az <\xtag{if}> második argumentuma, amelyben
        lekérdezzük kalandorunk ügyességi pontjait a <\xtag{score}> jelölő
        segítségével. Majd következik az <\xtag{if}> igaz és hamis ága, melyben
        <\xtag{text}> jelölővel szöveget iratunk ki.
      
      \item Csata
      
        Ebben a példában egy csata leírása látható. A
        <\xtag{fight}> jelölők közé jönnek az
        <\xtag{enemy}> jelölők. A <\xtag{fight}> a csatát
        jelenti. Az <\xtag{enemy}> pedig az ellenfelet. Itt csak egy ellenfél
        található, de ha több lénnyel kell megküzdenie hősünknek,
        akkor az <\xtag{enemy}> jelölők száma nő.
        \begin{minted}{xml}
<fight>
  <enemy agility="9" health="10">Ogre</enemy>
</fight>
        \end{minted}

      \item Pontok vesztése, visszaszerzése
        Ebben a példában azt, hogy a hősünk nyer 1 \stat{életerő pontot} a
        <\xtag{heal}> jelölő segítségével írtam le. A \attr{stat}
        attribútumában megadtam, hogy a életerő jellemző
        változtatásáról van tehát szó, és a nyitó és csukó jelölők közé írt
        számmal növekszik az érték. Ehhez az <\xtag{intlit}
        {\color{Attr}value}={\color{Value}''1''}> volt a segítségemre.
        Hasonlóan írtam le a 2 \stat{ügyességi pont} elvésztését a <\xtag{damage}>
        jelölővel. A \attr{stat} attribútumban megadtam az ügyesség
        jellemzőt, és az <\xtag{intlit}> segítségével pedig a számot,
        amennyivel csökkenteni szeretném az értéket.
        \begin{minted}{xml}
<p>
  A szökőkút hideg vize felfrissít, de furcsa mellékhatása van. 
  Nyersz 1 ÉLETERŐ pontot,
  <heal stat="health">
    <intlit value="1"/>
  </heal>      
  de vesztesz 2 ÜGYESSÉGI pontot,
  <damage stat="agility">
    <intlit value="2"/>
  </damage>            
  mert a víztől igen gyorsan megöregszel.
  Elszántan mész tovább az alagútban - <goto ref="329"/>.
</p>
        \end{minted}
    \end{itemize}
    
  \section{Fejlesztői dokumentáció}
    Tehát a nagyprogramomban két részt lehet élesen elkülöníteni. Az
    egyik a motor, mely beolvassa az xml fájlt, átfordítja saját
    nyelvre, műveleteket elvégzi és ad egy kimenetet. Ez a kimenet
    minden információt tartalmaz a kinézettel kapcsolatban, hogy
    mikor érünk új oldalra, mikor van csata, hová lehet menni az
    adott oldalról,\dots stb. 
    \subsection{Motor}
    A nagyprogramomnak tárolni kell különböző információkat. Például ha
    kaland során felveszünk egy tárgyat, azt valahol meg kell jegyeznünk, mert a
    későbbiekben fel akarjuk használni. Tehát szükségünk van valamilyen
    állapotra, mely folyamatosan módosul, és melyet lekérdezhetünk
    időről időre.
    Ezt az állapotot egy algebrai adattípussal írtam le, mely az
    alábbi:
    \begin{minted}{haskell}
    data GameState = GS { player\_state :: PlayerState
                        , fight\_state :: Maybe FightState
                        , page\_state :: Map Die Int
                        }
                   deriving (Show, Read)
    \end{minted}
    Így a játék állapotában szükségünk van a játékos állapotára, melyet
    lejjebb fogok részletezni. A player\_state írja le ezt. Mivel csaták is lehetnek a kaland során, amikor
    egy különös lénnyel találkozunk, ezért kell egy csata állapota
    is. Az implementáció miatt ez opcionális vagyis vagy van ilyen
    fight\_state vagy nincs, attól függően, hogy épp hacolunk-e vagy
    csak kalandozunk. A page\_state a kockadobások eredményeit
    tárolja. Amikor dobunk egyet a kockával, később le akarjuk
    kérdezni az eredményét, mert ez befolyásolja kalandunk további
    kimenetét az adott oldalon.
    
    A játékos állapota: Kaland írásánál, kitalálásánál, hogy a
    történet minél színesebb, fordulatosabb legyen, sok információt
    kell eltárolnunk. Ilyen információ, hogy milyen eszközöket viszünk
    magunkkal kezdetben, vagy miket találtunk eddig az út során.  Ezt
    tárolja a player\_carries nevű mező az állapotban.

    Vannak olyan események, melyeket nem lehet egyszerűen azzal
    leírni, hogy eltesszük, mint egy tárgyat. Például, hogy jártunk
    egy könyvtárban, ahol egy könyvben olvastunk kalandunk hátteréről.
    Itt kiderülhet egy nagyon fontos részlet. Ha majd sikeresen elérkezünk
    kalandunk végkimeneteléhez, akkor például egy adott folyosón
    semmiképpen se jobbra, hanem balra menjünk, mert jobbra egy csapda
    vár ránk. Ezt fel kell jegyeznünk magunknak. Ehhez hasonló
    információkat tárol a player\_flags.

    Ebben a kokrét kalandban, amit feldolgoztam, az volt a feladat,
    hogy összegyűjtsünk gyűrűket. Ezt számon kellett tartani, így
    szükség volt egy olyan adatszerkezetre, mely tárolja a gyűjtött
    tárgy nevét és hogy eddig mennyit találtunk belőle. Ez kezdetben
    0, majd minden esetben, ahol egy újabb gyűrűt találtunk, csak a
    gyűrűk számát növeltem eggyel. Erre való a player\_counters nevű mező.

    Játékos ,,létrehozásánál'' az első lépés, hogy meghatározzuk az
    életerő, ügyességi és szerencse pontjait. (A papíros játékban is
    ezzel kezdődött a kaland és itt a programban is ez az első lépés,
    amikor elkezdünk játszani.) A játék szabálya azt mondja, hogy ezen
    értékeket folyamatosan befolyásolja a kalandok sokasága, de nem
    csökkenhet 0 alá (mert az azt jelenti, hogy a kalador elbukta
    küldetését), és nem nőheti túl a kezdeti értéket. Ezért az aktuális
    értékek eltárolása mellett szükségünk van arra is, hogy kezdetben
    mennyi volt ez az érték. Ezért van player\_stats
    mező, mely minden tulajdonsághoz tárolja az aktuális és kezdeti értékeket.

    További fontos információ, melyet lépésről lépésre változtatunk,
    lekérdezünk, hogy hányadik oldalon tartunk éppen a
    küldetésünkben. Erre szolgál a player\_page.

    Ezek alapján kaptam tehát a játékos állapotát:
    \begin{minted}{haskell}
    data PlayerState = PS { player\_carries :: Set Item
                          , player\_flags :: Set Flag
                          , player\_counters :: Map Counter Int
                          , player\_stats :: Map Stat (Int, Int)
                          , player\_page :: PageNum
                          }
                     deriving (Show, Read)
    \end{minted}

    Harc/csata állapota: Egy csata folyamán előfordulhat, hogy csak egy
    lénnyel kell megküzdenünk, de lehet az is, hogy többel. Ezért
    itt el kell tárolnunk az összes ilyen mesebeli
    szörnyet, akik arra várnak, hogy megtámadhassanak. A szabályok
    szerint egyszerre csak egy lénnyel kell megküzdenünk, tehát egymás
    után következnek. A szörnyek tárolása a fight\_enemies listában történik.

    Az implementáció miatt volt szükség feljegyeznem,
    hogy mi volt az előző forduló, ezt a fight\_last\_round teszi
    meg.

    A könyv formája olyan, hogy az oldal elején leírja a
    történetet, itt találkozunk egy (vagy több) ellenféllel, majd az
    oldal alján van a megjegyzés, hogy ha győztes kimenetelű
    számunkra csata, akkor merre menjünk, ellenkező esetben vége a
    játékunknak. A programom írásánál úgy gondoltam, hogy nem
    szeretném, ha a kimenetben rögtön megjelenne, hogy merre van a
    továbbvezető út, mert ekkor még nem releváns számunkra. Úgy
    gondoltam, hogy akkor szeretném ezt megjeleníteni, ha már
    legyőztük ellenségeinket, különben egyáltalan ne jelenjen
    meg. Így a fight\_cont nevű mezőben tárolom a csata utáni
    folytatást, ami az oldal folyatását reprezentálja.
    \begin{minted}{haskell}
    data FightState = FS { fight\_enemies :: [Enemy]
                         , fight\_last\_round :: Maybe FightRound
                         , fight\_cont :: [PageItem]
                         }
                    deriving (Show, Read)
    \end{minted}
    
    Monádok a háttérben: egy CyoaT nevű monád van a háttérben, mely
    egy monád-interfészt húz az állapot kezelése fölé. Ez minden olyan
    műveletet nyújt,
    amivel meg lehet változtatni az állapotot.
    Tehát a CyoaT monádom egy monádtranszformátor, melynek külseje
    egy error monád, a belseje pedig egy RWST monádtranszformátor, ami
    az IO monád fölött van. A Reader monádban tárolom a magukat az
    oldalakat, és amikor elérkezünk egy új oldalra, akkor csak le kell
    kérdezni az aktuálisat. A Writer monádba kerül a kimenet, amely
    egy további algebrai adattípus. A State monád pedig egy játék
    állapotot ír le.
    Az IO monádra a kiírás miatt van szükség.
    \begin{minted}{haskell}
    newtype CyoaT m a = CyoaT { unCyoaT :: ErrorT GameEvent
      (RWST (Array PageNum Page, [PageItem])
      Output GameState m) a }
    deriving (Monad, Functor, MonadIO,
            MonadError GameEvent,
            MonadState GameState, MonadReader (Array PageNum Page,
            [PageItem]), MonadWriter Output,
            Applicative)
    \end{minted}

    A monád műveletei:
    \begin{minted}{haskell}
modifyPlayerState :: (Monad m) => (PlayerState -> PlayerState) -> CyoaT m ()
modifyPlayerState f = modify $ \gs -> gs{ player_state = f (player_state gs) }
    \end{minted}
    Tehát a modifyPlayerState módosítja a játék állapotát. A
    paraméterül kapott PlayerState -> PlayerState függvény mondja meg,
    hogy mi a módosítás.
    \begin{minted}{haskell}
modifyFightState :: (Monad m) => (FightState -> FightState) -> CyoaT m ()
modifyFightState f = modify $ \gs -> gs{ fight_state = f' (fight_state gs) }
  where f' = Just . f. fromJust
      \end{minted}
    Hasonlóan az előzőhöz a csata állapotát is tudnunk kell
    módosítani, hogy éppen mi történik. Ki támad kit, kinek sikerült
    csapást bevinnie.

    \begin{minted}{haskell}
takeItem :: (Monad m) => Item -> CyoaT m ()
takeItem item =
  modifyPlayerState $ \ps -> ps { player_carries = Set.insert item
    (player_carries ps) }
    \end{minted}
    Tágy felvételénél a játékos állapotában tároljuk, hogy eddig mikre
    tett szert. Ha egy új tárgyat talál, akkor azt
    megjegyezzük, módosítva az állapotunkat azzal, hogy egy új elem
    bekerült a halmazunkba.

    \begin{minted}{haskell}
dropItem :: (Monad m) => Item -> CyoaT m ()
dropItem item =
  modifyPlayerState $ \ps -> ps { player_carries = Set.delete item
    (player_carries ps) }
    \end{minted}
    Akkor is a játékos állapota változik, ha eldob vagy felhasznál egy tárgyat.

    \begin{minted}{haskell}
carries :: (Monad m) => Item -> CyoaT m Bool
carries item =
  gets $ Set.member item . player_carries . player_state
    \end{minted}
    Szükségünk lehet lekédezni, hogy egy adott elemmel
    rendelkezünk-e. Ennek segítségére van ez a carries függvény.

    \begin{minted}{haskell}
flagSet :: (Monad m) => Flag -> CyoaT m Bool
flagSet flag = gets $ Set.member flag . player_flags . player_state

setFlag :: (Monad m) => Flag -> CyoaT m ()
setFlag flag =
  modifyPlayerState $ \ps -> ps { player_flags = Set.insert flag
    (player_flags ps) }

resetFlag :: (Monad m) => Flag -> CyoaT m ()
resetFlag flag =
  modifyPlayerState $ \ps -> ps { player_flags = Set.delete flag
    (player_flags ps) }
    \end{minted}
    Egy különleges helyzet megjegyzésére szolgál. (Amely nem egy
    tárgyfelvétel hanem, hogy például jártunk-e egy adott helyen vagy
    megettünk-e egy ételt, amit kalandunk közben találtunk.) Ezt az
    információt meg tudjuk jegyezni, le tudjuk kérdezni és lehet, hogy
    egy olyan információról van szó, melyet fel tudunk használni. Ezen
    információk leírására van.

    \begin{minted}{haskell}
getCounter :: (Monad m) => Counter -> CyoaT m Int
getCounter counter = do
  lookup <- gets $ Map.lookup counter . player_counters . player_state
  return $ 0 `fromMaybe` lookup

modifyCounter :: (Monad m) => (Int -> Int) -> Counter -> CyoaT m ()
modifyCounter f counter = do
  modifyPlayerState $ \ps -> ps { player_counters = Map.alter f' counter (player_counters ps) }
  where f' mx = Just $ f $ 0 `fromMaybe` mx
    \end{minted}
    Ebben a könyben, melyet feldolgoztam gyűrűket kell
    gyűjteni. Amikor találunk egy újabbat, akkor változik a játékos
    állapota úgy, hogy fel kell jegyeznünk, hogy még egy ilyen
    gyűjtött tárgyat találtunk. A modifyCounter vátoztatja meg az
    állatpotot. A paraméterül kapott Int -> Int függvény mondja meg,
    hogy mennyi az új érték a régi függvényében, ezután ennyi darab
    lesz a tarsolyunkban. A getCounter pedig lekérdezi az állapotból.

    \begin{minted}{haskell}
getStat :: (Monad m) => Stat -> CyoaT m Int
getStat a = gets $ fst . fromJust . Map.lookup a . player_stats
. player_state
    \end{minted}
    A getStat függvénnyel a paraméterül kapott jellemzőt (életerő,
    ügyesség, szerencse) kérdezhetjük le.

    \begin{minted}{haskell}
modifyStat :: (Monad m) => (Int -> Int) -> Stat -> CyoaT m ()
modifyStat f stat = do
  modifyPlayerState $ \ps -> ps { player_stats = Map.alter (Just . f'
    . fromJust) stat (player_stats ps) }
  when (stat == Health) $ do
    health <- getStat Health
    when (health == 0) $ do
      emit [outText "Életerő pontjaid elfogytak, kalandod itt véget ér."]
      die

  where f' (current, initial) = (new, initial)
          where new = clamp (0, initial) (f current)
        clamp (low, high) x | x < low = low
                            | x > high = high
                            | otherwise = x
    \end{minted}
    Hasonló, mint az előbb, ez is a játékos jellemzőivel
    foglalkozik. Míg ott lekérdeztük, itt módosítjuk a jellemzőket. A
    kaland során találkozhatunk olyannal, hogy megsérülünk, ekkor az
    életerőnk csökken. Ennek módosítása ezzel a függvénnyel
    történik. A játékszabályokban az is benne van, hogy ezek a pontok
    nem csökkenhetnek 0 alá. Ilyen esetben a kimenetbe elküldjük, hogy
    ,,Életerő pontjaid elfogytak, kalandod itt véget ér.'' Azonban a
    kezdeti érték fölé sem mehetnek gyógyulás alkalmával. Erre is fel
    van készítve ez a függvény.

    \begin{minted}{haskell}
getDice :: (Monad m) => Die -> CyoaT m Int
getDice d = gets (fromJust . Map.lookup d . page_state)

addDice :: (Monad m) => Die -> Int -> CyoaT m ()
addDice d value = modify $ \gs -> gs{ page_state = Map.insert d value (page_state gs) }

clearDice :: (Monad m) => CyoaT m ()
clearDice = modify $ \gs -> gs{ page_state = Map.empty }

die :: (Monad m) => CyoaT m ()
die = do
  throwError DeathEvent
  \end{minted}

    Ezek a függvények a kockadobás miatti állapotváltozásokat,
    állapotlekérdezéseket kezelik. A getDice művelettel egy konkrét
    kockának az értékét kérdezzük le. Az addDice egy új kockát
    definiál egy konkrét étrékkel. A clearDice kitörli az eddigi kockadobásokat.

    \subsection{Megjelenítés}
\end{document}
